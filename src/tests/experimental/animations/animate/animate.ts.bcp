import { TAnimationFunction, TAnimationFunctionRequiringHTMLElements, TStyleState } from '../animations/types';
import { NormalizeProgression } from '../functions';
import { TAnimateFunction } from './types';
import {
  $delay, CancellablePromise, IAdvancedAbortSignal, ICancellablePromise, ICancellablePromiseOptions,
  IsAdvancedAbortSignal, TNativePromiseLikeOrValue
} from '@lifaon/observables';
import { IsObject } from '../../../../misc/helpers/is/IsObject';
import {
  NormalizeIterableOfTupleOrObject, TIterableOfTupleOrObject, TTupleFromInterface, TTupleOrObject
} from './normalize-iterable-of-tuple-or-object';

// export interface ICreateAnimateFunctionOptions {
//   // loop?: boolean;
//   reverse?: boolean;
// }

/**
 * Creates an <animate function> for an <animation> with a specific 'duration': when called, it runs <animation>
 */
export function CreateAnimateFunctionFromAnimation<GArgs extends any[]>(
  animation: TAnimationFunction<GArgs>,
  duration: number,
): TAnimateFunction<GArgs> {
  return (options?: ICancellablePromiseOptions, ...args: GArgs): ICancellablePromise<void> => {

    return new CancellablePromise<void>((
      resolve: (value?: TNativePromiseLikeOrValue<void>) => void,
      reject: (reason?: any) => void,
      signal: IAdvancedAbortSignal,
    ) => {
      const startTime: number = Date.now();
      let initialized: boolean = false;
      let handle: any;

      const clear = () => {
        abortListener.deactivate();
      };

      const loop = () => {
        if (!initialized) {
          initialized = true;
          animation('start', ...args);
        }

        const progress: number = NormalizeProgression((Date.now() - startTime) / duration);

        animation(progress, ...args);

        if (progress < 1) {
          handle = requestAnimationFrame(loop);
        } else {
          animation('end', ...args);
          clear();
          resolve();
        }
      };

      handle = requestAnimationFrame(loop);

      const abortListener = signal
        .addListener('abort', () => {
          animation(0, ...args);
          clear();
          cancelAnimationFrame(handle);
        }).activate();

    }, options);
  };
}

/**
 * Creates an <animate function> for an <animation> (expecting a list of HTMLElements) with a specific 'duration' and list of elements
 */
export function CreateAnimateFunctionFromHTMLElementsAnimationWithKnownElements(
  animation: TAnimationFunctionRequiringHTMLElements,
  duration: number,
  elements: ArrayLike<HTMLElement>,
): TAnimateFunction<[]> {
  const _animation: TAnimateFunction<[ArrayLike<HTMLElement>]> = CreateAnimateFunctionFromAnimation(animation, duration);
  return (options?: ICancellablePromiseOptions) => {
    return _animation(options, elements);
  };
}

/**
 * Creates an <animate function> for an <animation> (expecting a list of HTMLElements) with a specific 'duration' and css selector for the elements
 */
export function CreateAnimateFunctionFromHTMLElementsAnimationWithCSSSelector(
  animation: TAnimationFunctionRequiringHTMLElements,
  duration: number,
  selector: string,
  parentElement: ParentNode = document,
): TAnimateFunction<[]> {
  const _animation: TAnimateFunction<[ArrayLike<HTMLElement>]> = CreateAnimateFunctionFromAnimation(animation, duration);
  return (options?: ICancellablePromiseOptions) => {
    return _animation(options, parentElement.querySelectorAll(selector));
  };
}

/**
 * Creates an <animate function> for an <animation> (expecting a list of HTMLElements) with a specific 'duration' and list of elements or a selctor
 */
export function CreateAnimateFunctionFromHTMLElementsAnimation(
  animation: TAnimationFunctionRequiringHTMLElements,
  duration: number,
  elements: ArrayLike<HTMLElement> | string,
): TAnimateFunction<[]> {
  return (typeof elements === 'string')
     ? CreateAnimateFunctionFromHTMLElementsAnimationWithCSSSelector(animation, duration, elements)
     : CreateAnimateFunctionFromHTMLElementsAnimationWithKnownElements(animation, duration, elements);
}

/*-------------------------*/

/**
 * Creates an <animate function> used to delay some execution
 */
export function CreateDelayAnimateFunction(timeout: number): TAnimateFunction<[]> {
  return (options: ICancellablePromiseOptions = {}) => {
    return $delay(timeout, options);
  };
}

export function CreateLoopAnimateFunction<GArgs extends any[]>(
  animateFunction: TAnimateFunction<GArgs>
): TAnimateFunction<GArgs> {
  return (options?: ICancellablePromiseOptions, ...args: GArgs) => {
    const loop = (signal: IAdvancedAbortSignal): ICancellablePromise<void> => {
      return animateFunction({ signal }, ...args)
        .then((result: void, signal: IAdvancedAbortSignal) => {
          return loop(signal);
        });
    }
    if (IsObject(options) && IsAdvancedAbortSignal((options as ICancellablePromiseOptions).signal)) {
      return loop((options as ICancellablePromiseOptions).signal as IAdvancedAbortSignal);
    } else {
      throw new Error(`You must provide an AdvancedAbortSignal for this looping animate function`);
    }
  };
}

/**
 * Creates an <animate function> which runs in parallel many <animate functions>
 */
export function CreateParallelAnimateFunction<GArgs extends any[]>(
  animateFunctions: TAnimateFunction<GArgs>[],
): TAnimateFunction<GArgs> {
  return (options?: ICancellablePromiseOptions, ...args: GArgs) => {
    return CancellablePromise.all(
      animateFunctions.map((animate: TAnimateFunction<GArgs>) => {
        return (signal: IAdvancedAbortSignal) => animate({ signal }, ...args);
      })
    ).then(() => {
    });
  };
}

/**
 * Creates an <animate function> which runs in sequence many <animate functions>
 */
export function CreateSequentialAnimateFunction<GArgs extends any[]>(
  animateFunctions: TAnimateFunction<GArgs>[],
): TAnimateFunction<GArgs> {
  return (options?: ICancellablePromiseOptions, ...args: GArgs) => {
    return animateFunctions.reduce((promise: ICancellablePromise<void>, animateFunction: TAnimateFunction<GArgs>) => {
      return promise.then((value: void, signal: IAdvancedAbortSignal) => animateFunction({ signal }, ...args));
    }, CancellablePromise.resolve<void>(void 0, options));
  };
}

/*-----------------------*/



// export interface TAnimationWithWeightObject<GArgs extends any[]> {
//   animation: TAnimateFunction<GArgs>;
//   weight: number;
// }
//
//
// export type TAnimationWithWeightTuple<GArgs extends any[]> = [TAnimateFunction<GArgs>, number];
//
// export type TAnimationWithWeight<GArgs extends any[]> = TAnimationWithWeightObject<GArgs> | TAnimationWithWeightTuple<GArgs>;
//
//
// export interface TNormalizedAnimationWithWeight<GArgs extends any[]> extends TAnimationWithWeightObject<GArgs> {
//   startProgression: number;
//   endProgression: number;
// }
//
// export function NormalizeAnimationWithWeightIterable<GArgs extends any[]>(
//   animationsWithWeight: Iterable<TAnimationWithWeight<GArgs>>
// ): TNormalizedAnimationWithWeight<GArgs>[] {
//
//   const preNormalizedAnimationsWithWeight: TAnimationWithWeightObject<GArgs>[] = Array.from(
//     animationsWithWeight,
//     (animationWithWeight: TAnimationWithWeight<GArgs>, index: number) => {
//       if (Array.isArray(animationWithWeight)) {
//         return {
//           animation: animationWithWeight[0],
//           weight: animationWithWeight[1],
//         };
//       } else if (IsObject(animationWithWeight)) {
//         return animationWithWeight;
//       } else {
//         throw new TypeError(`Expected TAnimationWithWeight at index ${ index }`);
//       }
//     }
//   );
//
//   const totalWeight: number = preNormalizedAnimationsWithWeight.reduce((totalWeight: number, animationWithWeight: TAnimationWithWeightObject<GArgs>, index: number) => {
//     if (Number.isFinite(totalWeight) && (totalWeight >= 0)) {
//       return totalWeight + animationWithWeight.weight;
//     } else {
//       throw new RangeError(`weight must be in the range [0, Infinity[ at index ${ index }`);
//     }
//   }, 0);
//
//   if (Number.isFinite(totalWeight)) {
//     throw new RangeError(`totalWeight is infinite`);
//   }
//
//   let startProgression: number = 0;
//   return preNormalizedAnimationsWithWeight.map((animationWithWeight: TAnimationWithWeightObject<GArgs>) => {
//     const weight: number = animationWithWeight.weight / totalWeight;
//     const endProgression: number = startProgression + weight;
//     const normalizedAnimationWithWeight: TNormalizedAnimationWithWeight<GArgs> =  {
//       animation: animationWithWeight.animation,
//       weight,
//       startProgression,
//       endProgression,
//     };
//     return normalizedAnimationWithWeight;
//   });
// }
//
// export function CreateSequentialAnimateFunctionFromAnimationsWithWeight<GArgs extends any[]>(
//   animationsWithWeight: Iterable<TAnimationWithWeight<GArgs>>
// ): TAnimateFunction<GArgs> {
//   const normalizedAnimationsWithWeight: TNormalizedAnimationWithWeight<GArgs>[] = NormalizeAnimationWithWeightIterable<GArgs>(animationsWithWeight);
//
//   return (options?: ICancellablePromiseOptions, ...args: GArgs) => ICancellablePromise<void> {
//
//   };
// }



/*--*/

// export interface TAnimationWithDurationObject<GArgs extends any[]> {
//   animation: TAnimationFunction<GArgs>;
//   duration: number;
// }
//
//
// export type TAnimationWithDurationTuple<GArgs extends any[]> = [TAnimationFunction<GArgs>, number];
//
// export type TAnimationWithDuration<GArgs extends any[]> = TAnimationWithDurationObject<GArgs> | TAnimationWithDurationTuple<GArgs>;
//
// export function NormalizeAnimationWithDurationIterable<GArgs extends any[]>(
//   animationsWithDuration: Iterable<TAnimationWithDuration<GArgs>>
// ): TAnimationWithDurationObject<GArgs>[] {
//   return Array.from(
//     animationsWithDuration,
//     (animationWithDuration: TAnimationWithDuration<GArgs>, index: number) => {
//       if (Array.isArray(animationWithDuration)) {
//         return {
//           animation: animationWithDuration[0],
//           duration: animationWithDuration[1],
//         };
//       } else if (IsObject(animationWithDuration)) {
//         return animationWithDuration;
//       } else {
//         throw new TypeError(`Expected TAnimationWithDuration at index ${ index }`);
//       }
//     }
//   );
// }

export type TAnimationWithDurationKeys = ['animation', 'duration'];

export interface TAnimationWithDurationObject<GArgs extends any[]> {
  animation: TAnimationFunction<GArgs>;
  duration: number;
}

export type TAnimationWithDuration<GArgs extends any[]> = TTupleOrObject<TAnimationWithDurationKeys, TAnimationWithDurationObject<GArgs>>;

export function NormalizeAnimationWithDurationIterable<GArgs extends any[]>(
  items: TIterableOfTupleOrObject<TAnimationWithDurationKeys, TAnimationWithDurationObject<GArgs>>
): TAnimationWithDurationObject<GArgs>[] {
  return NormalizeIterableOfTupleOrObject<TAnimationWithDurationKeys, TAnimationWithDurationObject<GArgs>>(
    ['animation', 'duration'],
    items
  );
}

export function CreateSequentialAnimateFunctionFromAnimationsWithDuration<GArgs extends any[]>(
  items: TIterableOfTupleOrObject<TAnimationWithDurationKeys, TAnimationWithDurationObject<GArgs>>
): TAnimateFunction<GArgs> {
  return CreateSequentialAnimateFunction<GArgs>(
    NormalizeAnimationWithDurationIterable<GArgs>(items)
      .map((item: TAnimationWithDurationObject<GArgs>) => {
        return CreateAnimateFunctionFromAnimation<GArgs>(item.animation, item.duration);
      })
  );
}


/*--*/

export type TStateWithWeightKeys = ['state', 'weight'];

export interface TStateWithWeightObject {
  state: TStyleState;
  weight: number;
}

export type TStateWithWeight = TTupleOrObject<TStateWithWeightKeys, TStateWithWeightObject>;


export function NormalizeStateWithWeightIterable(
  items: TIterableOfTupleOrObject<TStateWithWeightKeys, TStateWithWeightObject>
): TStateWithWeightObject[] {
  return NormalizeIterableOfTupleOrObject<TStateWithWeightKeys, TStateWithWeightObject>(
    ['state', 'weight'],
    items
  );
}

export function CreateSequentialAnimateFunctionFromStatesWithWeight<GArgs extends any[]>(
  items: TIterableOfTupleOrObject<TStateWithWeightKeys, TStateWithWeightObject>
): TAnimateFunction<GArgs> {
  return CreateSequentialAnimateFunction<GArgs>(
    NormalizeAnimationWithDurationIterable<GArgs>(items)
      .map((normalizedAnimationWithDuration: TAnimationWithDurationObject<GArgs>) => {
        return CreateAnimateFunctionFromAnimation<GArgs>(normalizedAnimationWithDuration.animation, normalizedAnimationWithDuration.duration);
      })
  );
}

// export function animate_seq_states<GArgs extends any[]>(
//   states: TStyleState[],
// ): TAnimateFunction<GArgs> {
//   const length: number = states.length;
//
//   if (length < 2) {
//     throw new Error(`Min 2 states required`);
//   } else {
//     const animations: any[] = [];
//     for (let i = 1; i < length; i++) {
//       animations.push();
//     }
//   }
//
//   // [
//   //   animate(animation(showFront, showRight), duration),
//   //   animate(animation(showRight, showRight), duration),
//   // ])
// }






